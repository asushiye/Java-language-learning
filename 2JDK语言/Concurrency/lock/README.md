# Java lock   ------ java 锁

		饥饿和公平 - Starvation and Fairness
			Java中饥饿的原因
			用Java实现公平
		锁 - lock
		读写锁 - read / write lock  
		重入锁定 - Reentrance Lockout
		信号量 - Semaphore 
		滑倒的条件  - Slipped Conditions


## 饥饿和公平 - Starvation and Fairness
	
如果一个线程没有被授予CPU时间，因为其他线程全部抓住它，它被称为 **饥饿**。线程被“饿死”，因为其他线程允许CPU时间而不是它。

饥饿的解决方案被称为 **公平** - 所有线程都被公认为有机会执行。

### Java中饥饿的原因

以下三个常见原因可能导致Java中线程的饥饿：

1. 具有高优先级的线程会从优先级较低的线程中吞下所有CPU时间。
2. 线程被无限期地阻塞，等待进入同步块，因为其他线程在它之前一直被允许访问。
3. 等待一个对象的线程（在它上面称为wait（））仍然无限期地等待，因为其他线程不断被唤醒而不是它。

具有高优先级的线程会从优先级较低的线程中吞下所有CPU时间，解决方法是

您可以单独设置每个线程的线程优先级。优先级越高，授予线程的CPU时间越多。

您可以将线程的优先级设置在1到10之间。具体解释方式取决于运行应用程序的操作系统。对于大多数应用程序，您最好保持优先级不变。

线程被无限期地阻塞，等待进入同步块

Java的同步代码块可能是饥饿的另一个原因。 Java的同步代码块不保证允许进入同步块的线程进入的顺序。

这意味着存在一个理论风险，即线程在尝试进入块时永远被阻塞，因为其他线程在它之前一直被授予访问权限。

这个问题被称为“饥饿”，一个线程被“饿死”，因为其他线程被允许CPU时间而不是它。

等待一个对象的线程（在它上面称为wait（））仍然无限期地等待

如果多个线程调用了对象notify（）上的wait（），则notify（）方法不保证唤醒哪个线程。它可能是任何等待的线程。

因此，存在等待某个对象的线程永远不会被唤醒的风险，因为其他等待的线程总是被唤醒而不是它。

### 用Java实现公平

虽然不可能在Java中实现100％的公平性，但我们仍然可以实现我们的同步构造以增加线程之间的公平性。

首先让我们研究一个简单的同步代码块：

如果多个线程调用doSynchronized（）方法，则会阻止其中一些线程，直到授予访问权限的第一个线程离开该方法。

如果阻止多个线程等待访问，则无法保证接下来授予哪个线程访问权限。

使用锁而不是同步块


一个公平的锁

了之前的Lock类变成了一个名为FairLock的公平锁


## 锁 - lock

锁是一种线程同步机制，如同步块，但锁可能比Java的同步块更复杂。 

锁（以及其他更高级的同步机制）是使用synchronized块创建的，因此我们不能完全摆脱synchronized关键字。

从Java 5开始，包java.util.concurrent.locks包含几个锁实现，因此您可能不必实现自己的锁

## 读写锁 - read / write lock 

读/写锁是比Java中的Locks文本中显示的Lock实现更复杂的锁。

想象一下，你有一个应用程序可以读取和写入一些资源，但写入它并不像读取它那么多。 

读取相同资源的两个线程不会导致彼此出现问题，因此多个想要读取资源的线程同时被授予访问权限，重叠。 

但是，如果单个线程想要写入资源，则不能同时进行其他读取或写入操作。 

要解决允许多个读取器但只允许一个写入器的问题，您将需要读/写锁定。

Java 5带有java.util.concurrent包中的读/写锁实现。 即便如此，了解其实施背后的理论仍然有用。

如果一个线程想要读取资源，只要没有线程正在写入它就没关系，并且没有线程请求对资源的写访问权。

通过优先考虑写访问请求，我们假设写请求比读请求更重要。此外，如果读取是最常发生的事情，并且我们没有优先考虑写入，则可能发生饥饿。

请求写访问权限的线程将被阻止，直到所有读者都解锁了ReadWriteLock。

如果新线程不断被授予读访问权限，则等待写访问的线程将无限期地被阻塞，从而导致饥饿。

因此，如果没有线程当前已锁定ReadWriteLock进行写入，或者请求将其锁定以进行写入，则只能授予线程读取访问权限。


## 重入锁定 - Reentrance Lockout

重入锁定是一种类似于死锁和嵌套监视器锁定的情况。锁定和读/写锁的文本中还部分介绍了重入锁定。

如果线程重新进入Lock，ReadWriteLock或其他不可重入的同步器，则可能会发生重入锁定。

可重入意味着已经拥有锁的线程可以重新获得它。 Java的同步块是可重入的。因此，以下代码可以正常工作

为避免重入锁定，您有两种选择：

1. 避免编写重新锁定的代码
2. 使用可重入锁
哪种选择最适合您的项目取决于您的具体情况。重入锁通常不如非重入锁执行，并且它们更难实现，但在您的情况下这可能不是一个问题。

无论是否使用锁重入，您的代码是否更容易实现必须根据具体情况确定。


## 信号量 - Semaphore 

信号量是一种线程同步结构，可用于在线程之间发送信号以避免丢失信号，或者像锁定一样保护关键部分。 

Java 5带有java.util.concurrent包中的信号量实现，因此您不必实现自己的信号量

## 滑倒的条件  - Slipped Conditions